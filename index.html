<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Site</title>
        <style>
            body {
                font-family: monospace;
                max-width: 60ch;
                margin: 2rem auto;
                padding: 0 1rem;
                line-height: 1.6;
            }
            a {
                color: blue;
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .index-item {
                display: inline;
            }
            .index-item::after {
                content: " ";
            }
            .frontmatter {
                margin-bottom: 2rem;
            }
            .frontmatter div {
                margin: 0.25rem 0;
            }
            .images {
                position: relative;
                margin: 2rem 0;
            }
            .image-container {
                box-sizing: border-box;
                position: absolute;
            }
            .image-container img {
                width: 100%;
                height: auto;
                display: block;
                image-rendering: pixelated;
            }
            .to-dither {
                visibility: hidden;
            }
            .dithered {
                visibility: visible;
            }
            .back {
                margin-bottom: 2rem;
            }
            .content {
                margin-top: 2rem;
            }
        </style>
    </head>
    <body>
        <div id="app"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
        <script>
            const app = document.getElementById("app");
            const PAGES_FOLDER = "pages";

            // Parse frontmatter from markdown
            function parseFrontmatter(content) {
                const frontmatterRegex =
                    /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
                const match = content.match(frontmatterRegex);

                if (!match) return { frontmatter: {}, content: content };

                const frontmatterText = match[1];
                const markdown = match[2];
                const frontmatter = {};

                frontmatterText.split("\n").forEach((line) => {
                    const colonIndex = line.indexOf(":");
                    if (colonIndex > -1) {
                        const key = line.substring(0, colonIndex).trim();
                        const value = line.substring(colonIndex + 1).trim();
                        frontmatter[key] = value;
                    }
                });

                return { frontmatter, content: markdown };
            }

            // Floyd-Steinberg dithering with monochrome conversion
            function ditherImage(img, callback) {
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");
                canvas.width = img.width;
                canvas.height = img.height;

                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(
                    0,
                    0,
                    canvas.width,
                    canvas.height,
                );
                const data = imageData.data;

                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;

                        // Convert to grayscale using luminance formula
                        const gray =
                            data[i] * 0.299 +
                            data[i + 1] * 0.587 +
                            data[i + 2] * 0.114;

                        // Threshold to black or white
                        const newVal = gray < 128 ? 0 : 255;

                        // Set all RGB channels to same value (monochrome)
                        data[i] = newVal;
                        data[i + 1] = newVal;
                        data[i + 2] = newVal;

                        // Calculate error
                        const err = gray - newVal;

                        // Distribute error to neighboring pixels
                        if (x + 1 < canvas.width) {
                            data[(y * canvas.width + x + 1) * 4] +=
                                (err * 7) / 16;
                            data[(y * canvas.width + x + 1) * 4 + 1] +=
                                (err * 7) / 16;
                            data[(y * canvas.width + x + 1) * 4 + 2] +=
                                (err * 7) / 16;
                        }
                        if (x - 1 >= 0 && y + 1 < canvas.height) {
                            data[((y + 1) * canvas.width + x - 1) * 4] +=
                                (err * 3) / 16;
                            data[((y + 1) * canvas.width + x - 1) * 4 + 1] +=
                                (err * 3) / 16;
                            data[((y + 1) * canvas.width + x - 1) * 4 + 2] +=
                                (err * 3) / 16;
                        }
                        if (y + 1 < canvas.height) {
                            data[((y + 1) * canvas.width + x) * 4] +=
                                (err * 5) / 16;
                            data[((y + 1) * canvas.width + x) * 4 + 1] +=
                                (err * 5) / 16;
                            data[((y + 1) * canvas.width + x) * 4 + 2] +=
                                (err * 5) / 16;
                        }
                        if (x + 1 < canvas.width && y + 1 < canvas.height) {
                            data[((y + 1) * canvas.width + x + 1) * 4] +=
                                (err * 1) / 16;
                            data[((y + 1) * canvas.width + x + 1) * 4 + 1] +=
                                (err * 1) / 16;
                            data[((y + 1) * canvas.width + x + 1) * 4 + 2] +=
                                (err * 1) / 16;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                callback(canvas.toDataURL());
            }

            // List your pages here
            const PAGES = ["first-post.md", "go.md"];

            // Show index page
            function showIndex() {
                app.innerHTML = PAGES.map(
                    (file) =>
                        `<span class="index-item"><a href="#${file}">${file.replace(".md", "")}</a></span>`,
                ).join(" ");
            }

            // Show individual page
            async function showPage(filename) {
                try {
                    const response = await fetch(`${PAGES_FOLDER}/${filename}`);
                    const content = await response.text();
                    const { frontmatter, content: markdown } =
                        parseFrontmatter(content);

                    let html = '<div class="back"><a href="#">‚Üê back</a></div>';

                    // Display frontmatter
                    html += '<div class="frontmatter">';
                    for (const [key, value] of Object.entries(frontmatter)) {
                        if (key !== "images") {
                            html += `<div><strong>${key}:</strong> ${value}</div>`;
                        }
                    }
                    html += "</div>";

                    // Display images if present
                    if (frontmatter.images) {
                        const images = frontmatter.images
                            .split(",")
                            .map((img) => img.trim());
                        html += '<div class="images">';
                        images.forEach((img) => {
                            const imgPath = `images/${img}`;
                            html += `
                            <div class="image-container">
                                <a href="${imgPath}" target="_blank">
                                    <img src="${imgPath}" data-original="${imgPath}" class="to-dither" alt="${img}">
                                </a>
                            </div>
                        `;
                        });
                        html += "</div>";
                    }

                    // Display markdown content
                    html += `<div class="content">${marked.parse(markdown)}</div>`;

                    app.innerHTML = html;

                    // Apply dithering to images
                    const containers =
                        document.querySelectorAll(".image-container");
                    const cols = 3;
                    const gap = 8;
                    const colWidth =
                        (app.offsetWidth - gap * (cols - 1)) / cols;
                    const colHeights = new Array(cols).fill(0);

                    containers.forEach((container, idx) => {
                        const img = container.querySelector(".to-dither");
                        const originalImg = new Image();
                        originalImg.crossOrigin = "anonymous";
                        originalImg.onload = function () {
                            ditherImage(this, (ditheredSrc) => {
                                img.src = ditheredSrc;
                                img.classList.remove("to-dither");
                                img.classList.add("dithered");

                                // Masonry layout
                                const ratio = this.height / this.width;
                                const height = colWidth * ratio;
                                const shortestCol = colHeights.indexOf(
                                    Math.min(...colHeights),
                                );

                                container.style.width = colWidth + "px";
                                container.style.left =
                                    shortestCol * (colWidth + gap) + "px";
                                container.style.top =
                                    colHeights[shortestCol] + "px";

                                colHeights[shortestCol] += height + gap;

                                // Set container height after all positioned
                                if (idx === containers.length - 1) {
                                    document.querySelector(
                                        ".images",
                                    ).style.height =
                                        Math.max(...colHeights) + "px";
                                }
                            });
                        };
                        originalImg.src = img.dataset.original;
                    });
                } catch (e) {
                    app.innerHTML =
                        '<div class="back"><a href="#">‚Üê back</a></div><p>Error loading page.</p>';
                }
            }

            // Router
            function route() {
                const hash = window.location.hash.slice(1);
                if (hash) {
                    showPage(hash);
                } else {
                    showIndex();
                }
            }

            window.addEventListener("hashchange", route);
            route();
        </script>
    </body>
</html>
